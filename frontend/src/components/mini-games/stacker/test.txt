import React, { useState, useEffect, useRef, useCallback } from 'react';

// For this single-file component, we assume Tone.js is available globally 
// from a <script> tag in the main HTML file.
// A check will be in place to handle if it's not.

const StackerGame = () => {
    const canvasRef = useRef(null);
    const [score, setScore] = useState(0);
    const [highScore, setHighScore] = useState(0);
    const [gameState, setGameState] = useState('waiting'); // 'waiting', 'playing', 'ended'
    const [isPerfectFlash, setIsPerfectFlash] = useState(false);

    // Ref to track gameState inside useCallback without adding it as a dependency
    const gameStateRef = useRef(gameState);
    useEffect(() => {
        gameStateRef.current = gameState;
    }, [gameState]);

    // Refs for game state values needed in the animation loop to avoid stale closures
    const stackRef = useRef([]);
    const currentBlockRef = useRef(null);
    const directionRef = useRef(1);
    const speedRef = useRef(2.5);
    const blockHeightRef = useRef(25);
    const baseUnitWidthRef = useRef(0);
    
    // Refs for Tone.js synths and animation frame
    const synthRef = useRef(null);
    const perfectSynthRef = useRef(null);
    const errorSynthRef = useRef(null);
    const animationFrameIdRef = useRef(null);

    const setupSounds = useCallback(() => {
        try {
            if (window.Tone) {
                if (!synthRef.current) {
                     synthRef.current = new window.Tone.Synth({
                        oscillator: { type: 'triangle' },
                        envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 }
                    }).toDestination();
                }
                if (!perfectSynthRef.current) {
                     perfectSynthRef.current = new window.Tone.Synth({
                        oscillator: { type: 'sine' },
                        envelope: { attack: 0.01, decay: 0.3, sustain: 0.2, release: 0.3 }
                    }).toDestination();
                }
                 if (!errorSynthRef.current) {
                     errorSynthRef.current = new window.Tone.Synth({
                        oscillator: { type: 'square' },
                        envelope: { attack: 0.02, decay: 0.5, sustain: 0.1, release: 0.5 }
                    }).toDestination();
                }
            }
        } catch (e) {
            console.error("Audio setup failed. Game will continue without sound.", e);
        }
    }, []);

    // Set up sounds once when the component mounts
    useEffect(() => {
        setupSounds();
    }, [setupSounds]);
    
    const draw = useCallback(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw grid
        ctx.strokeStyle = 'rgba(200, 200, 200, 0.1)';
        ctx.lineWidth = 1;
        for (let x = 0; x <= canvas.width; x += baseUnitWidthRef.current) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }
        for (let y = canvas.height; y >= 0; y -= blockHeightRef.current) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }

        const colorBands = [0, 60, 120, 180, 240, 300];

        // Draw stack
        stackRef.current.forEach((block, index) => {
            const bandIndex = Math.floor(index / 4) % colorBands.length;
            ctx.fillStyle = `hsl(${colorBands[bandIndex]}, 70%, 60%)`;
            ctx.fillRect(block.x, block.y, block.width, blockHeightRef.current);
        });

        // Draw current block
        if (gameStateRef.current === 'playing' && currentBlockRef.current) {
            const currentBandIndex = Math.floor(stackRef.current.length / 4) % colorBands.length;
            ctx.fillStyle = `hsl(${colorBands[currentBandIndex]}, 90%, 70%)`;
            ctx.fillRect(currentBlockRef.current.x, currentBlockRef.current.y, currentBlockRef.current.width, blockHeightRef.current);
        }
    }, []);

    const resetGame = useCallback(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        
        if (animationFrameIdRef.current) {
            cancelAnimationFrame(animationFrameIdRef.current);
        }

        let preferredWidth = Math.min(window.innerWidth * 0.9, 400);
        const baseUnits = 11;
        canvas.width = Math.floor(preferredWidth / baseUnits) * baseUnits;
        canvas.height = window.innerHeight * 0.8;
        
        baseUnitWidthRef.current = canvas.width / baseUnits;

        setScore(0);
        try {
            setHighScore(localStorage.getItem('stackerHighScore') || 0);
        } catch (e) {
            console.warn("Could not access localStorage. High score will not be saved.");
            setHighScore(0);
        }
        
        directionRef.current = 1;
        speedRef.current = 2.5;

        const startingBlockWidth = baseUnitWidthRef.current * 3;
        const baseBlock = {
            x: baseUnitWidthRef.current * 4,
            y: canvas.height - blockHeightRef.current,
            width: startingBlockWidth
        };
        stackRef.current = [baseBlock];

        currentBlockRef.current = {
            x: 0,
            y: canvas.height - 2 * blockHeightRef.current,
            width: startingBlockWidth
        };
        
        setGameState('waiting');
        draw();
    }, [draw]);
    
    useEffect(() => {
        resetGame();
        window.addEventListener('resize', resetGame);
        return () => window.removeEventListener('resize', resetGame);
    }, [resetGame]);

    const gameLoop = useCallback(() => {
        const block = currentBlockRef.current;
        if (!block) return;

        block.x += directionRef.current * speedRef.current;

        const canvas = canvasRef.current;
        if (block.x + block.width > canvas.width || block.x < 0) {
            directionRef.current *= -1;
            block.x = Math.max(0, Math.min(block.x, canvas.width - block.width));
        }
        
        draw();
        animationFrameIdRef.current = requestAnimationFrame(gameLoop);
    }, [draw]);
    
    const startGame = useCallback(async () => {
        try {
            if (window.Tone && window.Tone.context.state !== 'running') {
                await window.Tone.start();
            }
            // Sounds are already set up, we just need to start the context
        } catch (e) {
            console.error("Could not start audio. Game will continue without sound.", e);
        } finally {
            setGameState('playing');
        }
    }, []);
    
    const endGame = useCallback(() => {
        setGameState('ended');
        if(errorSynthRef.current) errorSynthRef.current.triggerAttackRelease('C3', '4n');
    }, []);

    useEffect(() => {
        if (gameState === 'playing') {
            animationFrameIdRef.current = requestAnimationFrame(gameLoop);
        } else {
            if (animationFrameIdRef.current) {
                cancelAnimationFrame(animationFrameIdRef.current);
            }
        }
        return () => {
            if (animationFrameIdRef.current) {
                cancelAnimationFrame(animationFrameIdRef.current);
            }
        };
    }, [gameState, gameLoop]);
    
    useEffect(() => {
        if (gameState === 'ended') {
            if (score > highScore) {
                setHighScore(score);
                try {
                    localStorage.setItem('stackerHighScore', score);
                } catch (e) {
                    console.warn("Could not save high score to localStorage.", e);
                }
            }
        }
    }, [gameState, score, highScore]);

    const dropBlock = useCallback(() => {
        const perfectPlacementMargin = 2;
        const prevBlock = stackRef.current[stackRef.current.length - 1];
        const currentBlock = currentBlockRef.current;

        const isPerfect = Math.abs(currentBlock.x - prevBlock.x) <= perfectPlacementMargin;
        const overlap = Math.max(0, Math.min(currentBlock.x + currentBlock.width, prevBlock.x + prevBlock.width) - Math.max(currentBlock.x, prevBlock.x));

        let newBlock;
        let newWidth;

        if (isPerfect) {
            setScore(s => s + 2);
            if(perfectSynthRef.current) perfectSynthRef.current.triggerAttackRelease('C5', '8n');
            setIsPerfectFlash(true);
            setTimeout(() => setIsPerfectFlash(false), 300);
            
            newWidth = prevBlock.width;
            newBlock = { x: prevBlock.x, y: currentBlock.y, width: newWidth };
        } else if (overlap > 0) {
            setScore(s => s + 1);
            if(synthRef.current) synthRef.current.triggerAttackRelease('C4', '8n');
            
            const prevUnits = prevBlock.width / baseUnitWidthRef.current;
            const successfulUnits = [];
            for (let i = 0; i < prevUnits; i++) {
                const unitX = prevBlock.x + i * baseUnitWidthRef.current;
                const unitEnd = unitX + baseUnitWidthRef.current;
                const currentEnd = currentBlock.x + currentBlock.width;
                if (unitX < currentEnd && unitEnd > currentBlock.x) {
                    successfulUnits.push(unitX);
                }
            }

            if (successfulUnits.length === 0) {
                endGame();
                return;
            }
            newWidth = successfulUnits.length * baseUnitWidthRef.current;
            newBlock = { x: successfulUnits[0], y: currentBlock.y, width: newWidth };
        } else {
            endGame();
            return;
        }

        stackRef.current.push(newBlock);
        
        if (stackRef.current.length * blockHeightRef.current > canvasRef.current.height * 0.75) {
             stackRef.current.forEach(block => block.y += blockHeightRef.current);
        }

        currentBlockRef.current = {
            x: 0,
            y: stackRef.current[stackRef.current.length - 1].y - blockHeightRef.current,
            width: newWidth
        };
        
        speedRef.current *= 1.035;
    }, [endGame]);

    const handleAction = useCallback(() => {
        if (gameState === 'waiting') {
            startGame();
        } else if (gameState === 'playing') {
            dropBlock();
        }
    }, [gameState, startGame, dropBlock]);
    
    useEffect(() => {
        const handleKeyDown = (e) => {
            if (e.code === 'Space' || e.key === ' ') {
                e.preventDefault();
                handleAction();
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [handleAction]);

    const getActionButtonText = () => {
        switch(gameState) {
            case 'waiting': return 'Start Game';
            case 'playing': return 'Drop Block';
            case 'ended': return 'Game Over';
            default: return 'Start Game';
        }
    };

    return (
        <>
            <style>{`
                @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');
                :root {
                    --background-color: #1a1a2e;
                    --primary-color: #16213e;
                    --secondary-color: #0f3460;
                    --accent-color: #e94560;
                    --perfect-color: #39ff14;
                    --text-color: #dcdcdc;
                }
                .game-wrapper {
                    font-family: 'Poppins', sans-serif;
                    background-color: var(--background-color);
                    color: var(--text-color);
                    width: 100vw;
                    height: 100vh;
                    overflow: hidden;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }
                #game-container {
                    position: relative;
                    width: 100%;
                    height: 100%;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    text-align: center;
                    transition: background-color 0.2s ease;
                }
                .perfect-flash { animation: flash 0.3s ease-out; }
                @keyframes flash {
                    0% { background-color: var(--background-color); }
                    50% { background-color: #2a2a4e; }
                    100% { background-color: var(--background-color); }
                }
                #ui-container {
                    position: absolute;
                    top: 3vh;
                    width: 100%;
                    z-index: 10;
                    padding: 20px;
                    box-sizing: border-box;
                    display: flex;
                    justify-content: space-around;
                    align-items: center;
                }
                .score-box { text-align: center; }
                .score-box .label {
                    font-size: clamp(0.8rem, 3vw, 1.2rem);
                    font-weight: 400;
                    opacity: 0.8;
                }
                .score-box .value {
                     font-size: clamp(1.5rem, 8vw, 3rem);
                     font-weight: 700;
                     color: white;
                     text-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
                }
                canvas { background-color: transparent; display: block; }
                #controls { position: absolute; bottom: 5vh; z-index: 10; }
                #action-button {
                    padding: 15px 30px;
                    font-size: 1.2rem;
                    font-weight: 600;
                    color: white;
                    background: var(--accent-color);
                    border: none;
                    border-radius: 12px;
                    cursor: pointer;
                    transition: all 0.2s ease-in-out;
                    box-shadow: 0 5px 15px rgba(233, 69, 96, 0.4);
                    min-width: 200px;
                }
                #action-button:hover:not(:disabled) {
                    transform: translateY(-3px);
                    box-shadow: 0 8px 25px rgba(233, 69, 96, 0.6);
                }
                #action-button:active:not(:disabled) { transform: translateY(1px); }
                #action-button:disabled {
                    background-color: #555;
                    cursor: not-allowed;
                    box-shadow: none;
                    transform: none;
                }
                #game-over-modal {
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(22, 33, 62, 0.95);
                    padding: 40px;
                    border-radius: 20px;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                    z-index: 100;
                    text-align: center;
                    backdrop-filter: blur(8px);
                    border: 1px solid rgba(255,255,255,0.1);
                }
                #game-over-modal h2 { font-size: 2.5rem; color: var(--accent-color); margin-top: 0; }
                #final-score { font-size: 1.8rem; margin-bottom: 15px; }
                #final-high-score { font-size: 1.2rem; margin-bottom: 30px; color: var(--perfect-color); }
                #restart-button {
                    padding: 15px 30px;
                    font-size: 1.2rem;
                    font-weight: 600;
                    color: white;
                    background: var(--perfect-color);
                    border: none;
                    border-radius: 12px;
                    cursor: pointer;
                    transition: all 0.2s ease-in-out;
                    box-shadow: 0 5px 15px rgba(57, 255, 20, 0.4);
                }
            `}</style>
            <div className="game-wrapper">
                <div id="game-container" className={isPerfectFlash ? 'perfect-flash' : ''}>
                    <div id="ui-container">
                        <div className="score-box">
                            <div className="label">HIGH SCORE</div>
                            <div className="value">{highScore}</div>
                        </div>
                         <div className="score-box">
                            <div className="label">SCORE</div>
                            <div className="value">{score}</div>
                        </div>
                    </div>
                    
                    <canvas ref={canvasRef}></canvas>

                    <div id="controls">
                         <button 
                            id="action-button" 
                            onClick={handleAction}
                            disabled={gameState === 'ended'}
                         >
                            {getActionButtonText()}
                        </button>
                    </div>
                   
                   {gameState === 'ended' && (
                        <div id="game-over-modal">
                            <h2>Game Over</h2>
                            <p id="final-score">Your Score: {score}</p>
                            <p id="final-high-score">High Score: {highScore}</p>
                            <button id="restart-button" onClick={resetGame}>Play Again</button>
                        </div>
                   )}
                </div>
            </div>
        </>
    );
};

export default StackerGame;


